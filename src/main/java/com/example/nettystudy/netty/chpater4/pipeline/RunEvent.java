package com.example.nettystudy.netty.chpater4.pipeline;

/**
 * packageName : com.example.nettystudy.netty.chpater4
 * fileName : RunEvent
 * author : taeil
 * date : 2023/08/31
 * description :
 * =======================================================
 * DATE          AUTHOR                      NOTE
 * -------------------------------------------------------
 * 2023/08/31        taeil                   최초생성
 */
public class RunEvent {
    // 이벤트 실행
    // 네티 이벤트 메서드는 데이터가 수신되면 네티가 자동으로 호출된다.

    // '자동으로 호출한다'의 의미
    // 네티 없이 일반 서버 네트워크 프로그램을 작성한다고 가정 -> 서버는 소켓으로 접속되어 있으며 데이터가 들어오기를 기다리고있다.
    // 이와 같은 상태일 때 서버에 다음과 같은 순서로 로직을 구현한다.
    // 1. 소켓에 데이터가 있는지 확인한다.
    // 2. 데이터가 있는지 확인하고, 데이터가 존재하면 데이터를 읽어들이는 메서드를 호출한다.
    // 3. 읽어들일 데이터가 존재하지 않는다면 데이터가 도착할 때까지 대기한다.
    // 4. 데이터를 기다리는 중에 네트워크가 끊어지면 에러 처리를 위한 메서드를 호출한다.

    // 일반적으로 예외에 대한 대비가 철저할수록 오류는 적어지지만 프로그램 복잡도는 증가하게 된다.
    // 채널로 프로그램을 작성할 때도 마찬가지다. -> 같은 관점에서 네티는 이벤트를 채널 파이프라인과 이벤트 핸들러로 추상화한다.
    // 네티를 사용하면 데이터가 수신되었는지 소켓의 연결이 끊어졌는지와 같은 예외 상태에서 메서드 호출에 관여할 필요가 없다.
    // 위와 같은 상태의 프로그램을 네티로 작성하면 다음과 같다.
    // 1. 부트스트랩으로 네트워크 애플리케이션에 필요한 설정을 지정한다.
    // 2. 부트스트랩에 이벤트 핸들러를 사용하여 채널 파이프라인을 구성한다.
    // 3. 이벤트 핸들러의 데이터 수신 이벤트 메서드에서 데이터를 읽어들인다.
    // 4. 이벤트 핸들러의 네트워크 끊김 이벤트 메서드에서 에러 처리를 한다.

    // 위와 같이 구현하면 네티의 이벤트 루프가 소켓 채널에서 발생한 이벤트에 해당하는 이벤트 메서드를 자동으로 실행한다.
    // 소켓 채널에 데이터가 수신되었을 때 네티가 이벤트 메서드를 실행하는 방법은 다음과 같다.
    // 1. 네티의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.
    // 2. 이벤트 핸들러에 데이터 수신 이벤트 메서드가 구현되어 있으면 실행한다.
    // 3. 데이터 수신 이벤트 메서득가 구현되어 있지 않으면 다음 이벤트 핸들러를 가져온다.
    // 4. 2번 단계를 수행한다.
    // 5. 채널 파이프라인에 등록된 마지막 이벤트 핸들러에 도달할 때까지 1번 단계를 반복한다.

    // 위와 같이 데이터를 처리하는 입출력은 네티가 이벤트로 관리하므로 해당 이벤트(위의 예에서는 데이터 수신 이벤트)에 해당하는 코드만 구현하면 된다.
    // 이와 같이 네티의 이벤트 모델을 따르면 프로그래머가 구현해야 할 코드의 구분과 위치가 명확해지고 더 적은 코드로 좋은 애플리케이션을 구현할 수 있다.
}